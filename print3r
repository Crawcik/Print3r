#!/usr/bin/perl

# == Print3r, written by Rene K. Mueller <spiritdude@gmail.com>
#
# License: GPLv3
#
# Description:
#  Command line tool to print parts to 3d printers without GUI
#  - slicing with slic3r backend
#  - printing via USB
#  - printing .scad, .stl, .amf, .obj and .gcode
#
# History:
# 2018/09/27: 0.0.4: code cleanup
# 2018/09/26: 0.0.3: renamed to Print3r, 'gcode' command added to send single lines
# 2018/09/24: 0.0.2: 'print' of scad, stl and gcode, 'render' of scad, stl and gcode
# 2018/09/22: 0.0.1: first version, barely functional: slice, print and slice+print works

use strict;
use Time::HiRes qw(time sleep);
use Device::SerialPort;

my $NAME = "Print3r";
my $VERSION = '0.0.4';
my %conf;
my @f;

my($me) = ($0=~/\/([^\/]+)/);

$conf{device} = '/dev/ttyUSB0';

# -- short to long option mapping
my %s2l = ('q'=>'quiet','v'=>'verbose','b'=>'baudrate','-d'=>'device');

# -- intern option (not to pass on to convertors)
my %internOption = ('quiet'=>1,'verbose'=>1,'device'=>1,'baudrate'=>1,'printer'=>1,'random-placement'=>1,'multiply-part'=>1,'scale-part'=>1,'rotate-part'=>1);

my %sliceExtSupported = ('stl'=>1,'amf'=>1,'obj'=>1,'3mf'=>1);

my $printer;
$printer->{build}->{x} = 210;
$printer->{build}->{y} = 210;
$printer->{build}->{z} = 180;

$conf{baudrate} = 115200;

foreach (@ARGV) {
   if(/^-(\w+)$/) {
      foreach my $f (split(/|/,$1)) {     # -- '-v' or '-vv' -> "--verbose=2"
         $conf{$s2l{$f}}++;
      }
      next;
   }
   $conf{$1}++, next if(/^--([\w\-]+)$/);
   $conf{$1} = $2, next if(/^--([\w\-]+)=(.*)$/);
   push(@f,$_);
}

if($conf{version}) {
   print "$NAME $VERSION\n";
   exit 0;
}

my $cmd = shift(@f);

if($conf{verbose}) {
   foreach my $k (keys %conf) {
      print "$k = $conf{$k}\n";
   }
   print "files: @f\n";
}   

$| = 1;

if($conf{printer}) {                # -- printer profile linked, extract useful information
   my $c = readSlicerConf($conf{printer});
   if($c->{bed_shape}) {
      my(@co) = split(/,/,$c->{bed_shape});
      ($printer->{build}->{x},$printer->{build}->{y}) = split(/x/,$co[2]);
   }
   foreach my $k (keys %conf) {     # -- transfer command-line args to slicer config
      next if($internOption{$k});
      my $k_ = $k; $k_ =~ s/-/_/g;
      $c->{$k_} = $conf{$k};
   }
   foreach my $k (keys %$c) {       # -- transfer slicer config to printer settings (slicer independent)
      $printer->{$k} = $c->{$k};
   }
}

if($cmd eq 'analyze') {
   foreach my $fn (@f) {
      my $i;
      if($fn =~ /\.stl$/i) {
         $i = readSTL($fn);
      } elsif($fn =~ /\.gcode$/i) {
         $i = readGcode($fn);
      } else {
         print "$me: ERROR: file-format not supported: <$fn>, only .stl, .gcode\n";
      }
      print toJSON($i) if($i);
   }

} elsif($cmd eq 'render') {
   header();
   foreach my $fn (@f) {
      my $i;
      my @rm;
      $conf{output} = $fn; $conf{output} =~ s/\.[^\/\.]$/.png/;
      if($fn =~ /\.scad$/i) {
         $i = renderScad($fn,\%conf);
      } elsif($fn =~ /\.stl$/i) {
         $i = renderSTL($fn,\%conf);
      } elsif($fn =~ /\.gcode$/i) {
         $i = renderGcode($fn,\%conf);
      } else {
         print "$me: ERROR: file-format not supported: <$fn>, only .stl, .gcode\n";
      }
      unlink @rm if(@rm);
   }
   
} elsif($cmd eq 'slice') {
   header();
   foreach my $fn (@f) {
      $conf{output} = $fn; $conf{output} =~ s/\.[^\/\.]$/.gcode/;
      slicePart($fn,\%conf);
   }
   
} elsif($cmd eq 'print') {
   header();
   my(@rm);
   my(@fx);

   foreach my $fn (@f) {
      if($fn=~/\.scad$/i) {
         $conf{output} = "/tmp/print3r-$$.stl";
         scadToSTL($fn,\%conf);
         $fn = $conf{output};
         push(@rm,$fn);
      }

      if($fn=~/\.(\w+)$/ && $sliceExtSupported{$1}) {
         $conf{output} = "/tmp/print3r-$$.gcode";
         #slicePart($fn,\%conf);
         #$fn = $conf{output};
         #push(@rm,$fn);
         push(@fx,$fn);                # -- we gather all parts (.stl,.amf,.obj, etc)

      } elsif($fn=~/\.gcode$/i) {      # -- already .gcode, we print direct
         printGcode($fn,\%conf);
      } else {
         print "$me: ERROR: can't print <$fn>, skipped.\n";
      }
   }
   if(@fx) {                           # -- slice all parts together and print then
      my $fn = $conf{output} = "/tmp/print3r-$$.gcode";
      slicePart(\@fx,\%conf); 
      push(@rm,$fn);
      printGcode($fn,\%conf);
   }
   unlink @rm if(@rm);
   
} elsif($cmd eq 'gcode') {
   my $tmp = "/tmp/print3r-$$.gcode";
   open(my $fh,">",$tmp);
   print $fh "G4 S1\n";    # -- wait 1 sec, required for Marlin otherwise following commands go nowhere
   print $fh join("\n",@f)."\n";
   print $fh "G4 S1\n";    # -- wait 1 sec at the end
   print join("\n",@f)."\n" if($conf{verbose});
   close $fh;
   
   printGcode($tmp,\%conf);
   unlink $tmp;
   
} else {
   print "$NAME ($me) $VERSION USAGE: [<options>] <cmd> <file1> [<...>]

   options:
      --verbose or -v or -vv  increase verbosity
      --quiet or -q           no output except fatal errors
      --baudrate=<n>          set baudrate, default: $conf{baudrate}
      --device=<d>            set device, default: $conf{device}
      --printer=<config.ini>  slic3r config of printer
      --version               display version and exit
      --output=<file>         define output file for 'slice' and 'render' command
      slice-only:
         --random-placement
         --multiply-part=<n>  
         --<key>=<value>      include any valid slic3r option (slic3r --help)

   commands:
      gcode <gcode-line> [...]
      slice <file.stl|amf..>  slice file to gcode (.stl, .amf, .obj, .3mf)
      print <file.gcode>      print gcode
         print <file.stl>     slice & print in one go
         print <file.scad>    convert, slice & print in one go
      analyze <file.gcode>
         analyze <file.stl>
         analyze <file.scad>
      render <file.gcode>     render an image
         render <file.stl>
         render <file.scad>
      help
   
   examples:
      $me --printer=my_printer.ini slice cube.stl
      $me --printer=my_printer.ini --layer-height=0.2 --output=test.gcode slice cube.stl
      $me --device=/dev/ttyUSB1 print test.gcode
      $me --device=/dev/ttyUSB1 --nozzle-diameter=0.5 --layer-height=0.4 --fill-density=0 print cube.stl
      $me --printer=my_printer.ini print cube.scad

";
}   

# ---------------------------------------------------------------------------------------------------------------

sub header {
   if(!$conf{quiet}) {
      print "== $NAME $VERSION == https://github.com/Spiritdude/Print3r\n";
      print "$me: conf: device $conf{device}, bed $printer->{build}->{x}x$printer->{build}->{y}mm";
      print ", nozzle/d $printer->{nozzle_diameter}mm" if($printer->{nozzle_diameter});
      print ", layer/h $printer->{layer_height}mm" if($printer->{layer_height});
      print ", filament/d $printer->{filament_diameter}mm" if($printer->{filament_diameter});
      print "\n";
   }
}

sub scadToSTL {
   my($fn) = shift;
   my(%conf) = %{@_[0]};
   
   if(fork()==0) {
      $conf{output} = "sample.stl" unless($conf{output});
      unlink $conf{output};
      my(@a) = ('openscad','-o',$conf{output},$fn);
      unless($conf{verbose}) {
         close STDOUT;
         close STDERR;
      }
      exec(@a);
   }
   print "$me: scad to stl: ";
   wait();
   if($?) {
      print "ERROR (bad options/arguments?)\n";
   } else {
      print "done.\n";
   }
}

sub renderScad {
   my($fn) = shift;
   my(%conf) = %{@_[0]};

   if(!$fn=~/\.scad$/i) {
      print "$me: ERROR: you can only render .scad files but not <$fn>, skipped\n";
      return;
   }
   if(fork()==0) {
      $conf{output} = "sample.png" unless($conf{output});
      unless($conf{verbose}) {
         close STDERR;
         close STDOUT;
      }
      unlink $conf{output};
      exec("openscad","-o",$conf{output},"--imgsize=512,512",$fn);
   }
   print "render png: ";
   wait();
   if($?) {
      print "ERROR (bad options/arguments?)\n";
   } else {
      print "done.\n";
   }
}

sub renderSTL {
   my($fn) = shift;
   my(%conf) = %{@_[0]};

   if(!$fn=~/\.stl$/i) {
      print "$me: ERROR: you can only render .stl files but not <$fn>, skipped\n";
      return;
   }
   my $tmp = "./print3r-$$.stl";
   if(fork()==0) {
      $conf{output} = "sample.png" unless($conf{output});
      if(open(my $fh,">",$tmp)) {
         print $fh "import(\"$fn\");\n"; 
         close $fh;
         unless($conf{verbose}) {
            close STDERR;
            close STDOUT;
         }
         unlink $conf{output};
         exec("openscad","-o",$conf{output},"--imgsize","512,512",$tmp);
      }
   }
   print "render stl: ";
   wait();
   unlink $tmp;
   if($?) {
      print "ERROR (bad options/arguments?)\n";
   } else {
      print "done.\n";
   }
}

sub _moveTo {
   my($p) = @_;
   print "$p->{x} $p->{y} $p->{z}\n";
}

sub _printTo {
   my($p) = @_;
   print "$p->{x} $p->{y} $p->{z}\n";
}

sub _3dto2d {
   my($p,$pe,$im) = @_;
   my($x,$y);
   my $view;
   my $loc;
   
   $view->{x} = $printer->{build}->{x} / 2;
   $view->{y} = -$printer->{build}->{y} * 0.8;
   $view->{z} = $printer->{build}->{z} * 0.8;
   
   $loc->{x} = 0; #$printer->{build}->{x} / 2;
   $loc->{y} = 0; #$printer->{build}->{y} / 2;
   $loc->{z} = 0;
   
   if($pe eq 'side') {
      $x = $p->{y}*$im->{width}/$printer->{build}->{y};
      $y = $im->{height}-$p->{z}*$im->{height}/$printer->{build}->{z};
   } elsif($pe eq 'front') {
      $x = $p->{x}*$im->{width}/$printer->{build}->{x};
      $y = $im->{height}-$p->{z}*$im->{height}/$printer->{build}->{z};
   } else {
      if(1) {
         my $x_ = $p->{x} - $view->{x} - $loc->{x};
         my $y_ = $p->{z} - $view->{z} - $loc->{y};
         my $z_ = $p->{y} - $view->{y} - $loc->{z};
         $x = (+($x_ / $z_)) * $im->{width}/2 + $im->{width}/2;
         $y = (-($y_ / $z_)) * $im->{height}/2 + $im->{height}/2;
      } else {
         $x = $p->{x}*$im->{width}/$printer->{build}->{x} + $p->{z}*$im->{height}/$printer->{build}->{z}/2;
         $y = $im->{height}-$p->{y}*$im->{height}/$printer->{build}->{y} - $p->{z}*$im->{height}/$printer->{build}->{z}/3;
      }
   }
   ($x+$im->{xoff},$y+$im->{yoff});
}

sub renderGcode {
   my($fn) = shift;
   my(%conf) = %{@_[0]};
   use GD;
   my($w,$h) = (512+256,512);
   my $im = new GD::Image($w,$h);
   my $col;

   $col->{bg} = $im->colorAllocate(255,255,255);
   $col->{extrusion} = $im->colorAllocate(128,200,128);
   $col->{box} = $im->colorAllocate(128,128,128);
   $col->{bed} = $im->colorAllocate(210,210,210);
   
   foreach my $r (0..200) {
      my $n = $im->colorAllocate($r*0.5,20+$r,$r*0.5);
      $col->{depth} = $n unless($col->{depth});
   }

   my($w0,$h0);
   my($w1,$h1);
   my($w2,$h2);
   
   if($printer->{build}->{x} >= $printer->{build}->{y}) {
      $w0 = 512, $h0 = $w0 / $printer->{build}->{x} * $printer->{build}->{y};
      $w1 = 512, $h1 = $w1 / $printer->{build}->{x} * $printer->{build}->{z};
      $w2 = 512, $h2 = $w2 / $printer->{build}->{y} * $printer->{build}->{z};
   } elsif($printer->{build}->{x} < $printer->{build}->{y}) {
      $h0 = 512, $w0 = $h0 / $printer->{build}->{y} * $printer->{build}->{x};
   }
   
   $im->rectangle(0,0,$w0,$h0,$col->{bed});
   $im->rectangle(512,0,512+$w1/2,$h1/2,$col->{bed});
   $im->rectangle(512,256,512+$w2/2,256+$h2/2,$col->{bed});
   
   $im->line(512,0,512,512,$col->{box});
   $im->line(512,256,512+256,256,$col->{box});
   $im->string(gdSmallFont,512+5,5,"front",$col->{box});
   $im->string(gdSmallFont,512+5,256+5,"side",$col->{box});

   $im->clip(0,0,512,512);
   $im->line(
      _3dto2d({x=>0,y=>0,z=>0},'perspective',{width=>$w0,height=>$h0}),
      _3dto2d({x=>$printer->{build}->{x},y=>0,z=>0},'perspective',{width=>$w0,height=>$h0}),$col->{bed});
   $im->line(
      _3dto2d({x=>$printer->{build}->{x},y=>0,z=>0},'perspective',{width=>$w0,height=>$h0}),
      _3dto2d({x=>$printer->{build}->{x},y=>$printer->{build}->{y},z=>0},'perspective',{width=>$w0,height=>$h0}),$col->{bed});
   $im->line(
      _3dto2d({x=>$printer->{build}->{x},y=>$printer->{build}->{y},z=>0},'perspective',{width=>$w0,height=>$h0}),
      _3dto2d({x=>0,y=>$printer->{build}->{y},z=>0},'perspective',{width=>$w0,height=>$h0}),$col->{bed});
   $im->line(
      _3dto2d({x=>0,y=>$printer->{build}->{y},z=>0},'perspective',{width=>$w0,height=>$h0}),
      _3dto2d({x=>0,y=>0,z=>0},'perspective',{width=>$w0,height=>$h0}),$col->{bed});

   $im->clip(0,0,512+256,512);
   
   if(!$fn=~/\.gcode$/i) {
      print "$me: ERROR: you can only render .gcode files but not <$fn>, skipped\n";
      return;
   }
   open(my $fh,"<",$fn);
   return if(!$fh);

   my($p,$lp);
   foreach my $i (qw(x y z e f)) {
      $lp->{$i} = $p->{$i} = 0;
   }
   while(<$fh>) {
      chop;
      next if(/^;/ || /^\s*$/);
      s/;.*$//;
      s/\*.*$//;
      my($c,$id) = (/^([MG])(\d+)/);
      if($c eq 'G' && $id == 1) {      # -- extrude
         my $px;
         foreach my $pa (split(/ /)) {
            $px->{lc($1)} = $2 if($pa=~/([XYZEF])([\d\.]+)/);
         }
         foreach my $k (keys %$px) {      # -- update $p
            $p->{$k} = $px->{$k};
         }
         if($px->{e}) {                   # -- move or extrude
            #_printTo($p);
            #$im->line($lx,$ly,$x,$y,$col->{extrusion});
            $im->line(_3dto2d($lp,'perspective',{width=>$w0,height=>$h0}),_3dto2d($p,'perspective',{width=>$w0,height=>$h0}),$p->{z}/$printer->{build}->{z}*200+$col->{depth});
            $im->line(_3dto2d($lp,'front',{xoff=>512,yoff=>0,width=>$w1/2,height=>$h1/2}),_3dto2d($p,'front',{xoff=>512,yoff=>0,width=>$w1/2,height=>$h1/2}),$col->{extrusion});
            $im->line(_3dto2d($lp,'side',{xoff=>512,yoff=>256,width=>$w2/2,height=>$h2/2}),_3dto2d($p,'side',{xoff=>512,yoff=>256,width=>$w2/2,height=>$h2/2}),$col->{extrusion});
         } else {
            #_moveTo($p);
         }
         foreach my $k (keys %$p) {
            $lp->{$k} = $p->{$k};
         }
      }
   }
   close $fh;
   
   $conf{output} = "sample.png" unless($conf{output});
   open(my $fh,">",$conf{output});
   binmode($fh);
   print $fh $im->png();
   close $fh;
}

sub slicePart {
   my($fn) = shift;
   my(%conf) = %{@_[0]};

   if($fn=~/\.(\w+)$/ && $sliceExtSupported{$1}) {
      print "$me: ERROR: you can only slice .stl, .amf, .obj or .3mf files but not <$fn>, skipped\n";
      return;
   }
   my $tmp = "/tmp/print3r-$$.gcode";
   my $rm;
   
   my @a = ('slic3r');

   # -- compose argument list for slic3r
   push(@a,'--load',$conf{printer}) if($conf{printer});
   push(@a,'--output',$tmp), $rm = $tmp unless($conf{output});
   push(@a,'--print-center',int($printer->{build}->{x}*(rand()*0.5+0.5/2)).",".int($printer->{build}->{y}*(rand()*0.5+0.5/2))) if($conf{'random-placement'});

	if(fork()==0) {
      foreach my $k (keys %conf) {
         next if($internOption{$k});
         push(@a,"--$k",$conf{$k});
      }
      if($conf{'multiply-part'}) {
         push(@a,"--merge");
         foreach(1..$conf{'multiply-part'}) {
            push(@a,ref($fn)?@$fn:$fn);
         }
      } else {
         if(ref($fn)eq'ARRAY') {
            push(@a,"--merge");
            push(@a,@$fn);
         } else {
            push(@a,$fn);
         }
      }
      print "exec: @a\n" if($conf{verbose});
      unless($conf{verbose}) {
         close STDERR;
         close STDOUT;
      }
      exec(@a);
   }
   print "$me: slice part".(ref($fn)?"s":"")." to gcode: ";
   wait();
   if($?) {
      print "ERROR (bad options/arguments?)\n";
   } else {
      open(my $fh,$conf{output});   # -- try to retrieve filament usage near end of .gcode file
      seek($fh,4096,-1);
      my $fu;
      while(<$fh>) {
         $fu = $1, last if(/filament used = ([\d\.]+)/);
      }
      close $fh;
      printf "filament usage %.2fcm, ",$fu/10 if($fu);
      print "done.\n";
   }
   unlink $rm if($rm);
}

sub readGcode {
   my($fn) = shift;
   my(%conf) = %{@_[0]};
   my $i = {};

   open(my $fh,"<",$fn);
   return if(!$fh);
   $i->{filename} = $fn;

   while(<$fh>) {
   }
   close $fh;
   return $i;
}

sub readSTL {
   my($fn) = shift;
   my(%conf) = %{@_[0]};
   my $i = {};

   open(my $fh,"<",$fn);
   return if(!$fh);
   $i->{filename} = $fn;

   while(<$fh>) {
   }
   close $fh;
   return $i;
}

sub printGcode {
   my($fn) = shift;
   my(%conf) = %{@_[0]};
   my $com = Device::SerialPort->new($conf{device}, 1);
   
   if(!$com) {
      die "$me: ERROR: can't open $conf{device}";
   }
   
   if($conf{baudrate}) {
      $com->baudrate($conf{baudrate}*1);

   } else {
      # -- probe baudrate
      my $bb;
      print "$me: print: configure serial\r" if(!$conf{quiet});
      foreach my $b (reverse(2400, 9600, 19200, 38400, 57600, 115200, 250000, 500000, 1000000)) {
         my $st = time();

         $com->baudrate($b);

         print "probe $b\n" if($conf{verbose}>1);

         $com->purge_all();
         $com->lookclear();
         
         $com->write("M115\n");

         sleep 0.2;

         while(1) {
            my($a,$in,$out,$x) = $com->status();
            if($in>0) {
               my($n,$rd) = $com->read($in);
               $rd =~ s/[\t\r\n]//g;
               print "> $rd\n" if($conf{verbose}>2);
               if($rd=~/echo/) {
                  $bb = $b;
                  last;
               } elsif($rd=~/[\0-\037]/) {     # -- gibberish
                  last;
               } else {
                  $bb = $b;
                  last;
               }
               sleep 0.2;
            }
            last if(time()-$st>1);
         }
         last if($bb);
         sleep 0.3;
      } 
      print "baudrate: $bb\n" if($conf{verbose});
      sleep 0.1;
      if(!$bb) {
         die "$me: ERROR: no viable baudrate for $conf{device} found, abort.\n";
      }
   }

   my $st = time();
   
   open(my $fh,"<",$fn);
   return if(!$fh);

   my $pos = 0;
   my $pos_tot = (stat($fn))[7];
   my $lcur_z;
   my $cur_z = 0;
   my $tot_e = 0;
   my $cur_e = 0;
   my $layer = 0;

   $SIG{INT} = sub {
      print "\n\taborting print ...\n";
      sleep 1;
      open(my $fh,"<","custom/abort.gcode");
      while(<$fh>) {
         my $abort;
         
         next if(/^\s*;/);
         $com->write($_);

         my($resp) = printerResponse($com,$_,{timeout=>20});
         last if($resp eq 'abort');
      }
      close($fh);
      exit -1;
   };
   my $status = "init";
   
   while(<$fh>) {
      $pos += length($_);
     
      my $eta = (time()-$st) / $pos * $pos_tot;     # -- total time
      $eta = (($st + $eta) - time()) / 60;          # -- relative
      my $now = (time()-$st)/60;

      # -- rudimentary catch layer changes, if small change then it's a layer change
      $cur_z = $1 if(/^G1 Z(\S+)/);
      $layer++, $lcur_z = $cur_z if($cur_z > 0 && ($cur_z - $lcur_z) < 1 && $lcur_z != $cur_z);
      $tot_e = $cur_e if(/^G92 E0/);
      $status = "printing", $cur_e = $tot_e + $1 if(/G1.*E([\d\.]+)/);
      $status = "heating" if(/^M109/);
      
      # -- status line
      if(!$conf{quiet}) {
         if($status ne 'printing') {
            printf "$me: print: %s: %dh %02dm elapsed\r",$status,int($now/60),$now%60;
         } else {
            printf "$me: print: %dh %02dm elapsed, eta %dh %02dm, %d%% complete ($pos of $pos_tot), z=%.2fmm, layer #%d, filament %.2fcm%s",
               int($now/60),$now%60,int($eta/60),$eta%60,100*$pos/$pos_tot,$cur_z,$layer,$cur_e/10,$conf{verbose}?"\n":"\r"
         }
      }
      next if(/^;/ || /^\s*$/);

      print "send: '$_'" if($conf{verbose});

      $com->write($_);
      my($resp) = printerResponse($com,$_,{callback=>sub {
         my($mesg,$com,$cmd) = @_;
         my $now = (time()-$st)/60;
         # ... e.g. parse while heating up the temperature(s)
         # " T:202.32 /205.00 B:25.28 /0.00 @:60 B@:0 W:?"
         printf "$me: print: %s: %dh %02dm elapsed\r",$status,int($now/60),$now%60;
      }});
   }
   close $fh;
   print "\n" if(!$conf{quiet});
}

sub printerResponse {
   my($com,$cmd,$arg) = @_;
   my $await_ok = ($cmd=~/^[GM]/);
   my $resp = '';
   my $st = time();
   
   while(1) {
      my($in,$out);
      (undef,$in,$out,undef) = $com->status();

      if($in) {
         print "# in:$in out:$out\n" if($conf{verbose}>1);
         my($n,$rd) = $com->read($in);
         $resp .= $rd;

         &{$arg->{callback}}($rd,$com,$cmd) if(defined $arg->{callback} && ref($arg->{callback})eq'CODE');

         if($await_ok) {
            print "> '$resp'\n" if($conf{verbose}>2);
            last if($resp =~ /ok/i);
            last if($resp =~ /start/i);
            sleep 0.05;
         } else {
            last;
         }

      } elsif($arg->{timeout} && time()-$st > $arg->{timeout}) {
         return 'abort';
         
      } else {
         sleep 0.05;
      }
   }
   
   return $resp;
}

sub readSlicerConf {
   my($fn) = @_;
   my $i;
   if(open(my $fh,"<",$fn)) {
      while(<$fh>) {
         chop;
         next if(/^\s*#/);
         $i->{$1} = $2 if(/^(\w+)\s*=\s*(\S.*)$/);
      }
      close $fh;
   }
   return $i;
}


