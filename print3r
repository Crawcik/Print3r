#!/usr/bin/perl

# == Print3r, written by Rene K. Mueller <spiritdude@gmail.com>
#
# License: GPLv3
#
# Description:
#  Command line tool to print parts to 3d printers without GUI
#  - slicing with slic3r backend
#  - printing via USB
#  - printing .scad, .stl, .amf, .obj and .gcode
#
# History:
# 2018/10/07: 0.0.8: absolute scaling like --scale=0,0,30mm or --scale=50mm
# 2018/10/06: 0.0.7: `PRINT3R` enviromental variable considered, 'baudrate=auto' probes baudrate
# 2018/10/04: 0.0.6: 'scale', 'rotate', 'translate' and 'mirror' implemented
# 2018/09/30: 0.0.5: slicing .scad, preparing other slicers (like CuraEngine)
# 2018/09/27: 0.0.4: code cleanup, 'gconsole' added
# 2018/09/26: 0.0.3: renamed to Print3r, 'gcode' command added to send single lines
# 2018/09/24: 0.0.2: 'print' of scad, stl and gcode, 'render' of scad, stl and gcode
# 2018/09/22: 0.0.1: first version, barely functional: slice, print and slice+print works

use strict;
use Time::HiRes qw(time sleep);
use Device::SerialPort;
use Math::Trig ':pi';
#use CAD::Format::STL;

my $NAME = "Print3r";
my $VERSION = '0.0.8';
my %conf;
my $process;
my @f;

my($me) = ($0=~/\/([^\/]+)$/);

# -- defaults
$conf{device} = '/dev/ttyUSB0';
$conf{slicer} = 'slic3r';
$conf{timeout} = 10;
$conf{printer} = "default.ini";
$conf{baudrate} = 115200;

# -- short to long option mapping
my %s2l = ('q'=>'quiet','v'=>'verbose','b'=>'baudrate','d'=>'device');

# -- intern option (not to pass on to convertors)
my %internOption = ('quiet'=>1,'verbose'=>1,'device'=>1,'baudrate'=>1,'printer'=>1,'slicer'=>1,'output'=>1,
   'random-placement'=>1,'multiply-part'=>1,'scale'=>1,'rotate'=>1,'translate'=>1,'mirror'=>1,'timeout'=>1,'scad-prepend'=>1);

my %sliceExtSupported = ('stl'=>1,'amf'=>1,'obj'=>1,'3mf'=>1);

my $printer;
$printer->{build}->{x} = 200;
$printer->{build}->{y} = 200;
$printer->{build}->{z} = 180;

foreach (split(/:/,$ENV{PRINT3R})) {
   $conf{$1} = '\1' if(/^([\w\-]+)$/);
   $conf{$1} = $2, next if(/^([\w\-]+)=(.*)$/);
}
foreach (@ARGV) {
   if(/^-(\w+)$/) {
      foreach my $f (split(/|/,$1)) {     # -- '-v' or '-vv' -> "--verbose=2"
         $conf{$s2l{$f}}++;
      }
      next;
   }
   $conf{$1} = '\1', next if(/^--([\w\-\.]+)$/);
   $conf{$1} = $2, next if(/^--([\w\-\.]+)=(.*)$/);
   push(@f,$_);
}

if($conf{version}) {
   print "$NAME $VERSION\n";
   exit 0;
}

my $cmd = shift(@f);

if($conf{verbose}) {
   foreach my $k (keys %conf) {
      print "$k = $conf{$k}\n";
   }
   print "files: @f\n";
}   

$| = 1;

if($conf{printer} && -e $conf{printer}) {                # -- printer profile linked, extract useful information
   my $c = readSlicerConf($conf{printer});
   if($c->{bed_shape}) {
      my(@co) = split(/,/,$c->{bed_shape});
      ($printer->{build}->{x},$printer->{build}->{y}) = split(/x/,$co[2]);
   }
   foreach my $k (keys %conf) {     # -- transfer command-line args to slicer config
      next if($internOption{$k});
      my $k_ = $k; $k_ =~ s/-/_/g;
      $c->{$k_} = $conf{$k};
   }
   foreach my $k (keys %$c) {       # -- transfer slicer config to printer settings (slicer independent)
      $printer->{$k} = $c->{$k};
   }
}

if($cmd eq 'analyze') {          # -- not yet
   foreach my $fn (@f) {
      my $i;
      if($fn =~ /\.stl$/i) {
         $i = readSTL($fn);
      } elsif($fn =~ /\.gcode$/i) {
         $i = readGcode($fn);
      } else {
         print "$me: ERROR: file-format not supported: <$fn>, only .stl, .gcode\n";
      }
      print toJSON($i) if($i);
   }

} elsif($cmd eq 'slice') {
   header();
   my(@rm);
   foreach my $fn (@f) {
      $conf{output} = $fn, $conf{output} =~ s/\.[^\/\.]$/.gcode/ if(!defined $conf{output});
      if($fn=~/\.scad$/i) {
         my $c_fn = $conf{output};
         $conf{output} = "/tmp/print3r-$$.stl";
         scadToSTL($fn,\%conf);
         $fn = $conf{output};
         $conf{output} = $c_fn;
         push(@rm,$fn);
      }
      slicePart($fn,\%conf);
   }
   unlink @rm if(@rm);
   
} elsif($cmd eq 'print' || $cmd eq 'render') {
   header();
   my(@rm);
   my(@fx);
   my $o = $conf{output};     # -- preserve original setting
   
   foreach my $fn (@f) {
      if($fn=~/\.scad$/i) {
         $conf{output} = "/tmp/print3r-$$.stl";
         scadToSTL($fn,\%conf);
         $fn = $conf{output};
         push(@rm,$fn);
      }

      if($fn=~/\.(\w+)$/ && $sliceExtSupported{lc($1)}) {
         $conf{output} = "/tmp/print3r-$$.gcode";
         #slicePart($fn,\%conf);
         #$fn = $conf{output};
         #push(@rm,$fn);
         push(@fx,$fn);                # -- we gather all parts (.stl,.amf,.obj, etc)

      } elsif($fn=~/\.gcode$/i) {      # -- already .gcode, we print direct
         if($cmd eq 'render') {
            $conf{output} = $fn, $conf{output} =~ s/\.\w+$/.png/;
            $conf{output} = $o if(defined $o);
            renderGcode($fn,\%conf);
         } else {
            printGcode($fn,\%conf);
         }
      } else {
         print "$me: ERROR: can't print <$fn>, skipped.\n";
      }
   }
   if(@fx) {                           # -- slice all parts together and print then
      my $fn = $conf{output} = "/tmp/print3r-$$.gcode";
      slicePart(\@fx,\%conf); 
      push(@rm,$fn);
      if($cmd eq 'render') {
         if($o) {
            $conf{output} = $o;
         } else {
            $conf{output} = $fn; $conf{output} =~ s/\.[^\/\.]$/.png/;
         }
         renderGcode($fn,\%conf);
      } else {
         printGcode($fn,\%conf);
      }
   }
   unlink @rm if(@rm);
   
} elsif($cmd eq 'gcode') {
   my $tmp = "/tmp/print3r-$$.gcode";
   open(my $fh,">",$tmp);
   print $fh "G4 S1\n";    # -- wait 1 sec, required for Marlin otherwise following commands go nowhere
   foreach (@f) {
      s/\\n/\n/g;
      print $fh $_."\n";
   }
   print $fh "G4 S1\n";    # -- wait 1 sec at the end
   print join("\n",@f)."\n" if($conf{verbose});
   close $fh;
   
   printGcode($tmp,\%conf);
   unlink $tmp;
   
} elsif($cmd eq 'gconsole') {
   $| = 1;
   print "== $NAME: Gcode Console ($cmd) - use CTRL-C or 'exit' or 'quit' to exit\n";
   print "   for valid Gcode see https://reprap.org/wiki/G-code\n";
   print "conf: device $conf{device}, ";

   my $com = Device::SerialPort->new($conf{device}, 1);

   configSerial($com);

   print "connected\n";
   while(1) {
      print "> ";
      $_ = readline(STDIN);
      s/^\*s//;
      s/\*s$//;
      exit if(/^quit\s*/ || /^exit\s*/i);
      $com->write($_);
      my($resp) = printerResponse($com,$_);
      print "-----\n$resp.\n";
   }
      
} else {
   print "$NAME ($me) $VERSION USAGE: [<options>] <cmd> <file1> [<...>]

   options:
      --verbose or -v or -vv  increase verbosity
      --quiet or -q           no output except fatal errors
      --baudrate=<n>          set baudrate, default: $conf{baudrate}
      --device=<d>            set device, default: $conf{device}
      --printer=<config.ini>  slic3r config of printer, default: $conf{printer}
      --version               display version and exit
      --output=<file>         define output file for 'slice' and 'render' command
      slice-only:
         --random-placement   place print randomly on the bed
         --multiply-part=<n>  multiply part(s)
         --scale=<x>,<y>,<z>     scale part x,y,z (absolute if 'mm' is appended)
         --scale=<f>             scale part f,f,f
         --rotate=<x>,<y>,<z>    rotate x,y,z
         --translate=<x>,<y>,<z> translate x,y,z
         --mirror=<x>,<y>,<z>    mirror x,y,z (0=keep, 1=mirror)
         --<key>=<value>      include any valid slic3r option (slic3r --help)

   commands:
      slice <file.stl|amf..>  slice file to gcode (.stl, .amf, .obj, .3mf)
         slice <file.scad>
      print <file.gcode>      print gcode
         print <file.stl>     slice & print in one go
         print <file.scad>    convert, slice & print in one go
      render <file.gcode>     render an image (use '--output=sample.png' or so)
         render <file.stl>
         render <file.scad>
      gcode <code1> [...]     send gcode lines
      gconsole                start gcode console
      help
   
   examples:
      ln -s my_printer.ini default.ini --OR-- export PRINT3R \"printer=my_printer.ini\"
      $me slice cube.stl
      $me --layer-height=0.2 --output=test.gcode slice cube.stl
      $me --printer=ender3.ini --device=/dev/ttyUSB1 print test.gcode
      $me --printer=corexy.ini --device=/dev/ttyUSB2 --nozzle-diameter=0.5 --layer-height=0.4 --fill-density=0 print cube.stl
      $me print cube.scad
      $me gcode 'G28 X Y' 'G1 X60' 'G28 Z'
      $me gconsole
      == Print3r: Gcode Console (gconsole) - use CTRL-C or 'exit' or 'quit' to exit
         for valid Gcode see https://reprap.org/wiki/G-code
         conf: device /dev/ttyUSB0, connected
      > M115
      ...

";
}   

# ---------------------------------------------------------------------------------------------------------------

sub header {
   if(!$conf{quiet}) {
      print "== $NAME $VERSION == https://github.com/Spiritdude/Print3r\n";
      print "$me: conf: device $conf{device}, bed $printer->{build}->{x}x$printer->{build}->{y}mm";
      print ", nozzle/d $printer->{nozzle_diameter}mm" if($printer->{nozzle_diameter});
      print ", layer/h $printer->{layer_height}mm" if($printer->{layer_height});
      print ", filament/d $printer->{filament_diameter}mm" if($printer->{filament_diameter});
      print "\n";
   }
}

sub scadToSTL {
   my($fn) = shift;
   my(%conf) = %{@_[0]};

   my $tmp = "/tmp/print3r-$$.scad";
   
   if(fork()==0) {
      $conf{output} = $fn, $conf{output} =~ s/.\w+$/.stl/ unless($conf{output});
      unlink $conf{output};
      my(@a) = ('openscad','-o',$conf{output},$fn);
      unless($conf{verbose}) {
         close STDOUT;
         close STDERR;
      }
      exec(@a);
   }
   print "$me: scad to stl: ";
   wait();
   if($?) {
      print "openscad: ERROR (bad options/arguments?)\n";
   } else {
      print "done.\n";
   }
   #unlink $tmp if(-e $tmp);
}

sub renderScad {
   my($fn) = shift;
   my(%conf) = %{@_[0]};

   if(!$fn=~/\.scad$/i) {
      print "$me: ERROR: you can only render .scad files but not <$fn>, skipped\n";
      return;
   }
   if(fork()==0) {
      $conf{output} = "sample.png" unless($conf{output});
      unless($conf{verbose}) {
         close STDERR;
         close STDOUT;
      }
      unlink $conf{output};
      exec("openscad","-o",$conf{output},"--imgsize=512,512",$fn);
   }
   print "render png: ";
   wait();
   if($?) {
      print "openscad: ERROR (bad options/arguments?)\n";
   } else {
      print "done.\n";
   }
}

sub renderSTL {
   my($fn) = shift;
   my(%conf) = %{@_[0]};

   if(!$fn=~/\.stl$/i) {
      print "$me: ERROR: you can only render .stl files but not <$fn>, skipped\n";
      return;
   }
   my $tmp = "./print3r-$$.stl";
   if(fork()==0) {
      $conf{output} = $fn, $fn =~ s/\.\w+$/.png/ unless($conf{output});
      if(open(my $fh,">",$tmp)) {
         print $fh "import(\"$fn\");\n"; 
         close $fh;
         unless($conf{verbose}) {
            close STDERR;
            close STDOUT;
         }
         unlink $conf{output};
         exec("openscad","-o",$conf{output},"--imgsize","512,512",$tmp);
      }
   }
   print "render stl: ";
   wait();
   unlink $tmp;
   if($?) {
      print "openscad: ERROR (bad options/arguments?)\n";
   } else {
      print "done.\n";
   }
}

sub _moveTo {
   my($p) = @_;
   print "$p->{x} $p->{y} $p->{z}\n";
}

sub _printTo {
   my($p) = @_;
   print "$p->{x} $p->{y} $p->{z}\n";
}

sub _3dto2d {
   my($p,$pe,$im) = @_;
   my($x,$y);
   my $view;
   my $loc;
   
   $view->{x} = $printer->{build}->{x} / 2;
   $view->{y} = -$printer->{build}->{y} * 1.5;
   $view->{z} = $printer->{build}->{z} * 0.8;
   
   $loc->{x} = 0;
   $loc->{y} = 0;
   $loc->{z} = 0;
   
   if($pe eq 'side') {
      $x = $p->{y}*$im->{width}/$printer->{build}->{y};
      $y = $im->{height}-$p->{z}*$im->{height}/$printer->{build}->{z};
   } elsif($pe eq 'front') {
      $x = $p->{x}*$im->{width}/$printer->{build}->{x};
      $y = $im->{height}-$p->{z}*$im->{height}/$printer->{build}->{z};
   } else {
      if(1) {
         my $x_ = $p->{x} - $view->{x} - $loc->{x};
         my $y_ = $p->{z} - $view->{z} - $loc->{y};
         my $z_ = $p->{y} - $view->{y} - $loc->{z};
         $z_ = $z_/2;
         $x = (+($x_ / $z_)) * $im->{width}/2 + $im->{width}/2;
         $y = (-($y_ / $z_)) * $im->{height}/2 + $im->{height}/2;
      } else {
         $x = $p->{x}*$im->{width}/$printer->{build}->{x} + $p->{z}*$im->{height}/$printer->{build}->{z}/2;
         $y = $im->{height}-$p->{y}*$im->{height}/$printer->{build}->{y} - $p->{z}*$im->{height}/$printer->{build}->{z}/3;
      }
   }
   ($x+$im->{xoff},$y+$im->{yoff});
}

sub renderGcode {
   my($fn) = shift;
   my(%conf) = %{@_[0]};

   if(!$fn=~/\.gcode$/i) {
      print "$me: ERROR: you can only render .gcode files but not <$fn>, skipped\n";
      return;
   }
   open(my $fh,"<",$fn);
   return if(!$fh);

   seek($fh,4096,-1);         # -- try to parse end of .gcode from slic3r to pick up metadata
   my $tail;
   while(<$fh>) {
      chop;
      if(/^; filament used = ([\d\.]+)/) {
         $process->{filament_used} = $1;
         $tail++;
      } elsif($tail && /^; (\w+) = (.*)/) {
         $printer->{$1} = $2;
      }
   }
   ($printer->{build}->{x},$printer->{build}->{y}) = split(/x/,(split(/,/,$printer->{bed_shape}))[2]) if($printer->{bed_shape});

   use GD;

   print "$me: render: ";

   my($w,$h) = (512+256,512);
   my $im = new GD::Image($w,$h);
   my $col;

   $col->{bg} = $im->colorAllocate(255,255,255);
   $col->{extrusion} = $im->colorAllocate(128,200,128);
   $col->{box} = $im->colorAllocate(128,128,128);
   $col->{bed} = $im->colorAllocate(200,200,200);
   $col->{bed_raster} = $im->colorAllocate(210,210,210);
   $col->{bed_raster2} = $im->colorAllocate(220,220,220);
   
   foreach my $r (0..200) {
      my $n = $im->colorAllocate($r*0.5,20+$r,$r*0.5);
      $col->{depth} = $n unless($col->{depth});
   }

   my($w0,$h0);
   my($w1,$h1);
   my($w2,$h2);
   
   if($printer->{build}->{x} >= $printer->{build}->{y}) {
      $w0 = 512, $h0 = $w0 / $printer->{build}->{x} * $printer->{build}->{y};
      $w1 = 512, $h1 = $w1 / $printer->{build}->{x} * $printer->{build}->{z};
      $w2 = 512, $h2 = $w2 / $printer->{build}->{y} * $printer->{build}->{z};
   } elsif($printer->{build}->{x} < $printer->{build}->{y}) {
      $h0 = 512, $w0 = $h0 / $printer->{build}->{y} * $printer->{build}->{x};
   }
   
   $im->rectangle(0,0,$w0,$h0,$col->{bed});
   $im->rectangle(512,0,512+$w1/2,$h1/2,$col->{bed});
   $im->rectangle(512,256,512+$w2/2,256+$h2/2,$col->{bed});
   
   $im->line(512,0,512,512,$col->{box});
   $im->line(512,256,512+256,256,$col->{box});
   $im->string(gdSmallFont,512+5,5,"front",$col->{box});
   $im->string(gdSmallFont,512+5,256+5,"side",$col->{box});

   $im->clip(0,0,512,512);

   my $p = new GD::Polygon;   # -- render bed with raster
   $p->addPt(
      _3dto2d({x=>0,y=>0,z=>0},'perspective',{width=>$w0,height=>$h0}));
   $p->addPt(
      _3dto2d({x=>$printer->{build}->{x},y=>0,z=>0},'perspective',{width=>$w0,height=>$h0}));
   $p->addPt(
      _3dto2d({x=>$printer->{build}->{x},y=>$printer->{build}->{y},z=>0},'perspective',{width=>$w0,height=>$h0}));
   $p->addPt(
      _3dto2d({x=>0,y=>$printer->{build}->{y},z=>0},'perspective',{width=>$w0,height=>$h0}));
   $im->filledPolygon($p,$col->{bed});

   for(my $i=0; $i<$printer->{build}->{x}; $i += 10) {
      my $n = 1;
      my $c = 'bed_raster';
      $n = 2, $c = 'bed_raster2' if($i%100==0);
      for(my $j=0; $j<$n; $j++) {
         $im->line(
            _3dto2d({x=>$i,y=>0,z=>0},'perspective',{xoff=>$j,width=>$w0,height=>$h0}),
            _3dto2d({x=>$i,y=>$printer->{build}->{y},z=>0},'perspective',{xoff=>$j,width=>$w0,height=>$h0}),
            $col->{$c}
         );
      }
   }                        
   for(my $i=0; $i<$printer->{build}->{y}; $i += 10) {
      my $n = 1;
      my $c = 'bed_raster';
      $n = 2, $c = 'bed_raster2' if($i%100==0);
      for(my $j=0; $j<$n; $j++) {
         $im->line(
            _3dto2d({x=>0,y=>$i,z=>0},'perspective',{yoff=>$j,width=>$w0,height=>$h0}),
            _3dto2d({x=>$printer->{build}->{x},y=>$i,z=>0},'perspective',{yoff=>$j,width=>$w0,height=>$h0}),
            $col->{$c}
         );
      }
   }                        
   $im->clip(0,0,512+256,512);
   
   seek($fh,0,0);             # -- back to the beginning
   
   my($p,$lp);
   
   foreach my $i (qw(x y z e f)) {
      $lp->{$i} = $p->{$i} = 0;
   }
   while(<$fh>) {
      chop;
      #next if(/^;/ || /^\s*$/);
      #s/;.*$//;
      s/\*.*$//;
      my($c,$id) = (/^([MG])(\d+)/);
      if($c eq 'G' && ($id == 1 || $id == 0)) {      # -- move or extrude
         my $px;
         foreach my $pa (split(/ /)) {
            $px->{lc($1)} = $2 if($pa=~/([XYZEF])([\d\.]+)/);
         }
         foreach my $k (keys %$px) {      # -- update $p
            $p->{$k} = $px->{$k};
         }
         if($px->{e}) {                   # -- move or extrude
            #_printTo($p);
            #$im->line($lx,$ly,$x,$y,$col->{extrusion});
            #$im->line(_3dto2d($lp,'perspective',{width=>$w0,height=>$h0}),_3dto2d($p,'perspective',{width=>$w0,height=>$h0}),$p->{z}/$printer->{build}->{z}*200+$col->{depth});
            $im->line(_3dto2d($lp,'perspective',{width=>$w0,height=>$h0}),_3dto2d($p,'perspective',{width=>$w0,height=>$h0}),$col->{extrusion});
            $im->line(_3dto2d($lp,'front',{xoff=>512,yoff=>0,width=>$w1/2,height=>$h1/2}),_3dto2d($p,'front',{xoff=>512,yoff=>0,width=>$w1/2,height=>$h1/2}),$col->{extrusion});
            $im->line(_3dto2d($lp,'side',{xoff=>512,yoff=>256,width=>$w2/2,height=>$h2/2}),_3dto2d($p,'side',{xoff=>512,yoff=>256,width=>$w2/2,height=>$h2/2}),$col->{extrusion});
         } else {
            #_moveTo($p);
         }
         foreach my $k (keys %$p) {
            $lp->{$k} = $p->{$k};
         }
      }
   }
   close $fh;
   my $l = 0;
   my $lh = 15;
   $im->string(gdSmallFont,5,5+$l,sprintf("%15s %.fx%.fmm",'bed',$printer->{build}->{x},$printer->{build}->{y}),$col->{box}); $l += $lh;
   if($printer->{nozzle_diameter}) {
      $im->string(gdSmallFont,5,5+$l,sprintf("%15s %.2fmm",'nozzle/d',$printer->{nozzle_diameter}),$col->{box}); $l += $lh;
   }
   if($printer->{layer_height}) {
      $im->string(gdSmallFont,5,5+$l,sprintf("%15s %.2fmm",'layer/h',$printer->{layer_height}),$col->{box}); $l += $lh;
   }
   if($printer->{filament_diameter}) {
      $im->string(gdSmallFont,5,5+$l,sprintf("%15s %.2fmm",'filament/d',$printer->{filament_diameter}),$col->{box}); $l += $lh;
   }
   if($process->{filament_used}) {
      $im->string(gdSmallFont,5,5+$l,sprintf("%15s %.2fm",'filament used',$process->{filament_used}/1000),$col->{box}); $l += $lh;
   }
   
   $conf{output} = $fn, $conf{output} =~ s/\.\w+$/.png/ unless($conf{output});
   open(my $fh,">",$conf{output});
   binmode($fh);
   print $fh $im->png();
   close $fh;
   print "$conf{output}, ";
   print "done.\n";
}

sub slicePart {
   my($fn) = shift;
   my(%conf) = %{@_[0]};

   if(!ref($fn) && $fn=~/\.(\w+)$/ && !$sliceExtSupported{lc($1)}) {
      print "$me: ERROR: you can only slice .stl, .amf, .obj or .3mf files but not <$fn>, skipped\n";
      return;
   }
   my $tmp = "/tmp/print3r-$$.gcode";
   my @rm;
   
   my @a = ($conf{slicer});

   print "$me: slice part".(ref($fn) && @$fn>1?"s":"")." to gcode: ";
   
   if($conf{slicer}eq'slic3r') {
      # -- compose argument list for slic3r
      push(@a,'--load',$conf{printer}) if($conf{printer});
      if(defined $conf{output}) {
         unlink $conf{output};
         push(@a,'--output',$conf{output});
      } else {
         push(@a,'--output',$tmp);
         push(@rm,$tmp);
      }
      if($conf{'random-placement'}) {
         my(@pos) = (int($printer->{build}->{x}*(rand()*0.5+0.5/2)),int($printer->{build}->{y}*(rand()*0.5+0.5/2)));
         # -- TODO: check if new printer works with size of part (we have to read the part(s) to know its dimension)
         #          in case there are multiple parts, we don't know how slic3r combines them ...
         push(@a,'--print-center',join(",",@pos));
         print "position [$pos[0],$pos[1]], " unless($conf{quiet});
      }
      if($conf{scale} || $conf{rotate} || $conf{translate} || $conf{mirror}) {
         my @fx = ();
         my $n = 0;
         foreach my $f (ref($fn)?@$fn:$fn) {
            my $p = stlRead($f);
            $p = stlRecenter($p);
            $p = stlMirror($p,[split(/,/,$conf{mirror})]) if(defined $conf{mirror});
            $p = stlScale($p,[split(/,/,$conf{scale})]) if(defined $conf{scale});
            $p = stlRotate($p,[split(/,/,$conf{rotate})]) if(defined $conf{rotate});
            $p = stlTranslate($p,[split(/,/,$conf{translate})]) if(defined $conf{translate});
            my $tmp = "/tmp/print3r-$$-$n.stl";
            stlWrite($tmp,$p);
            $n++;
            push(@fx,$tmp);
         }
         $fn = \@fx;
         push(@rm,@fx);
      }
   
   	if(fork()==0) {
         foreach my $k (keys %conf) {
            next if($internOption{$k});
            if($conf{$k} eq '\1') {
               push(@a,"--$k");
            } else {
               push(@a,"--$k",$conf{$k});
            }
         }
         if($conf{'multiply-part'}) {
            push(@a,"--merge");
            foreach(1..$conf{'multiply-part'}) {
               push(@a,ref($fn)?@$fn:$fn);
            }
         } else {
            if(ref($fn)eq'ARRAY') {
               push(@a,"--merge") if(@$fn>1);
               push(@a,@$fn);
            } else {
               push(@a,$fn);
            }
         }
         print "exec: @a\n" if($conf{verbose});
         unless($conf{verbose}) {
            close STDERR;
            close STDOUT;
         }
         exec(@a);
      }
   
   } else {    # -- cura
      $a[0] = "CuraEngine";
      push(@a,"slice");
      #push(@a,'-j',"Cura/resources/definitions/fdmprinter.def.json");
      push(@a,'-j',$conf{printer}) if($conf{printer});
      if($conf{output}) {
         push(@a,'-o',$conf{output});
      } else {
         push(@a,'-o',$tmp);
         push(@rm,$tmp);
      }
   	if(fork()==0) {
         foreach my $k (keys %conf) {
            next if($internOption{$k});
            push(@a,"-s","$k=\"$conf{$k}\"");
         }
         if($conf{'multiply-part'}) {
            foreach(1..$conf{'multiply-part'}) {
               foreach(ref($fn)?@$fn:$fn) {
                  push(@a,"-l",$_);
               }
            }
         } else {
            if(ref($fn)eq'ARRAY') {
               foreach(ref($fn)?@$fn:$fn) {
                  push(@a,"-l",$_);
               }
            } else {
               push(@a,"-l",$fn);
            }
         }
         print "exec: @a\n" if($conf{verbose});
         unless($conf{verbose}) {
            close STDERR;
            close STDOUT;
         }
         exec(@a);
      }
   }
   
   wait();
   my $exit = $? >> 8;
   if($conf{slicer}ne'slic3r' && $exit) {          # -- slic3r also fails if verbose=0 (stdout/stderr closed)
      print "$a[0]: ERROR (bad options/arguments?): $exit\n";
      exit;
   } else {
      if($conf{slicer}eq'slic3r') {
         if(open(my $fh,$conf{output})) {   # -- try to retrieve filament usage near end of .gcode file
            seek($fh,4096,-1);
            my $fu;
            while(<$fh>) {
               $fu = $1, last if(/filament used = ([\d\.]+)/);
            }
            close $fh;
            $process->{filament_used} = $fu, printf "filament usage %.2fm, ",$fu/1000 if($fu);
         } else {                           # -- slic3r did not provide any results
            print "$a[0]: ERROR (bad options/arguments?)\n";
            exit;
         }
      }
      print "done.\n";
   }
   unlink @rm if(@rm);
}

sub configSerial {
   my($com) = @_;

   die "$me: ERROR: can't open $conf{device}" if(!$com);

   if($conf{baudrate} && $conf{baudrate}ne'auto') {
      $com->baudrate($conf{baudrate}*1);

   } else {
      # -- probe baudrate (not yet used, mostly untested)
      my $bb;
      print "$me: print: configure serial\r" if(!$conf{quiet});
      foreach my $b (reverse(2400, 9600, 19200, 38400, 57600, 115200, 250000, 500000, 1000000)) {
         my $st = time();

         $com->purge_all;
         $com->baudrate($b);

         sleep 0.5;
         
         print "probe $b\n" if($conf{verbose}>1);

         $com->write("M115\n");

         sleep 0.2;

         my($rd) = printerResponse($com,"M115\n",{timeout => 1, callback => sub {
            my($rd,$com,$cmd) = @_;
            $rd =~ s/[\t\r\n]//g;
            print "> $rd\n" if($conf{verbose}>2);
         }});

         if($rd=~/echo/) {
            $bb = $b;
            last;
         } elsif($rd=~/[\0-\037]/) {     # -- gibberish
            last;
         } else {
            #$bb = $b;
            #last;
         }

         last if($bb);

         sleep 0.3;
      } 
      print "baudrate: $bb\n" if($conf{verbose});
      sleep 0.1;
      if(!$bb) {
         die "$me: ERROR: no viable baudrate for $conf{device} found, abort.\n";
      }
   }
}

sub printGcode {
   my($fn) = shift;
   my(%conf) = %{@_[0]};
   my $com = Device::SerialPort->new($conf{device}, 1);
   
   configSerial($com);

   my $st = time();
   
   open(my $fh,"<",$fn);
   return if(!$fh);

   my $pos = 0;
   my $pos_tot = (stat($fn))[7];
   my $lcur_z;
   my $cur_z = 0;
   my $tot_e = 0;
   my $cur_e = 0;
   my $layer = 0;

   $SIG{INT} = sub {
      print "\n\taborting print (max $conf{timeout}s) ...\n";
      sleep 1;
      open(my $fh,"<","gcode/abort.gcode");
      while(<$fh>) {
         my $abort;
         
         next if(/^\s*;/);
         $com->write($_);

         my($resp) = printerResponse($com,$_,{timeout=>$conf{timeout}});
         last if($resp eq 'abort');
      }
      close($fh);
      exit -1;
   };
   my $status = "init";
   my $lst;
   
   while(<$fh>) {
      $pos += length($_);
     
      my $eta = (time()-$st) / $pos * $pos_tot;     # -- total time
      $eta = (($st + $eta) - time()) / 60;          # -- relative
      my $now = (time()-$st)/60;

      # -- rudimentary catch layer changes, if small change then it's a layer change
      $cur_z = $1 if(/^G[01] .*Z(\S+)/);
      $layer++, $lcur_z = $cur_z if($cur_z > 0 && ($cur_z - $lcur_z) < 1 && $lcur_z != $cur_z);
      $tot_e = $cur_e if(/^G92 E0/);
      $status = "printing", $cur_e = $tot_e + $1 if(/G1.*E([\d\.]+)/);
      $status = "heating" if(/^M109/);
      
      # -- status line
      if(!$conf{quiet}) {
         if($status ne 'printing') {
            printf "$me: print: %s: %dh %02dm elapsed\r",$status,int($now/60),$now%60;
         } else {
            printf "$me: print: %dh %02dm elapsed, eta %dh %02dm, %.1f%% complete, z=%.2fmm, layer #%d, filament %.2fm%s",
               int($now/60),$now%60,int($eta/60),$eta%60,100*$pos/$pos_tot,$cur_z,$layer,$cur_e/1000,$conf{verbose}?"\n":"\r"
         }
      }
   
      next if(/^;/ || /^\s*$/);     # -- comments or empty lines are not sent

      print "send: '$_'" if($conf{verbose});

      $com->write($_);

      my($resp) = printerResponse($com,$_,{callback=>sub {
         my($mesg,$com,$cmd) = @_;
         my $now = (time()-$st)/60;
         if($status ne 'printing') {
            # ... e.g. parse while heating up the temperature(s)
            # " T:202.32 /205.00 B:25.28 /0.00 @:60 B@:0 W:?"
            if($status eq 'heating' && $mesg=~/(T:[\d\.]+ \/[\d\.]+) (B:[\d\.]+ \/[\d\.]+)/) {
               printf "$me: print: %s (%s, %s): %dh %02dm elapsed\r",$status,$1,$2,int($now/60),$now%60;
            } else {
               printf "$me: print: %s: %dh %02dm elapsed\r",$status,int($now/60),$now%60;
            }
         }
      }});
   
      if(time()-$lst>1) {
         $com->write(sprintf("M117 %d%% eta %s l#%d\n",100*$pos/$pos_tot,
            $eta > 36*60 ? int($eta/60/24)."dy" : $eta > 3*60 ? int($eta/60)."h" : int($eta)."m",
            $layer));
         printerResponse($com);
         $lst = time();
      }
   }
   close $fh;
   
   $com->write("M117 completed\n");
   printerResponse($com);
   
   print "\n" if(!$conf{quiet});
}

sub printerResponse {
   my($com,$cmd,$arg) = @_;
   my $await_ok = ($cmd=~/^[GM]/);
   my $resp = '';
   my $st = time();
   
   while(1) {
      my($in,$out);
      (undef,$in,$out,undef) = $com->status();

      if($in) {
         print "# in:$in out:$out\n" if($conf{verbose}>1);
         my($n,$rd) = $com->read($in);
         $resp .= $rd;

         &{$arg->{callback}}($rd,$com,$cmd) if(defined $arg->{callback} && ref($arg->{callback})eq'CODE');

         if($await_ok) {
            print "> '$resp'\n" if($conf{verbose}>2);
            last if($resp =~ /ok/i);
            last if($resp =~ /start/i);
            sleep 0.005;
         } else {
            last;
         }

      } elsif($arg->{timeout} && time()-$st > $arg->{timeout}) {
         return 'abort';
         
      } else {
         sleep 0.005;
      }
   }
   
   return $resp;
}

sub readSlicerConf {
   my($fn) = @_;
   my $i;
   if(open(my $fh,"<",$fn)) {
      while(<$fh>) {
         chop;
         next if(/^\s*#/);
         $i->{$1} = $2 if(/^(\w+)\s*=\s*(\S.*)$/);
      }
      close $fh;
   }
   return $i;
}

sub stlRead {
   my($fn) = @_;
   my $p = { };
   print "stl read <$fn>\n" if($conf{verbose});

   my(@min,@max);
   $min[0] = $min[1] = $min[2] = 1e6;
   $max[0] = $max[1] = $max[2] = -1e6;
   
   if(open(my $fh,"<",$fn)) {
      my $buff;
      read($fh,$buff,256);
      seek($fh,0,0);
      if($buff=~/facet/) {       # -- ascii
         my $v;
         my $n = 0;
         while(<$fh>) {
            chop;
            push(@$v,[split(/ /,$1)]) if(/vertex (\S.+)/);
            if(/endloop/) {
               push(@{$p->{facets}},$v);
               for(my $i=0; $i<3; $i++) {
                  for(my $j=0; $j<3; $j++) {
                     # -- update min/max
                     $min[$j] = $v->[$i]->[$j] if($v->[$i]->[$j]<$min[$j]);
                     $max[$j] = $v->[$i]->[$j] if($v->[$i]->[$j]>$max[$j]);
                  }
               }
               $v = [], $n++;
            }
         }
         print "$fn: $n facets\n" if($conf{verbose});
      } else {                   # -- binary
         my $n;
         read($fh,$buff,80);
         read($fh,$n,4);
         $n = unpack('i',$n);
         print "$fn: $n facets\n" if($conf{verbose});
         my $fu = 'f f f';
         for(my $i=0; $i<$n; $i++) {
            my($nr,$v1,$v2,$v3,$at);
            read($fh,$nr,4*3);
            read($fh,$v1,4*3);
            read($fh,$v2,4*3);
            read($fh,$v3,4*3);
            read($fh,$at,2);
            $at = unpack('s',$at);
            my $v;
            push(@$v,[unpack($fu,$v1)]);
            push(@$v,[unpack($fu,$v2)]);
            push(@$v,[unpack($fu,$v3)]);
            #print " @{@v[0]} @{@v[1]} @{@v[2]}\n";
            push(@{$p->{facets}},$v);
            for(my $i=0; $i<3; $i++) {
               for(my $j=0; $j<3; $j++) {
                  # -- update min/max
                  $min[$j] = $v->[$i]->[$j] if($v->[$i]->[$j]<$min[$j]);
                  $max[$j] = $v->[$i]->[$j] if($v->[$i]->[$j]>$max[$j]);
               }
            }
         }
      }
      close $fh;
      # -- keep min/max/size up-to-date
      $p->{min} = \@min;
      $p->{max} = \@max;
      $p->{size} = [$max[0]-$min[0],$max[1]-$min[1],$max[2]-$min[2]];
      return $p;
   } else {
      print STDERR "$NAME: only .stl supported, abort.\n";
      exit;
   }
}

sub stlWrite {
   my($fn,$p) = @_;
   print "stl writing <$fn>\n" if($conf{verbose});
   if(open(my $fh,">",$fn)) {
      print $fh "solid\n";
      foreach my $f (@{$p->{facets}}) {
         print $fh "facet normal 0 0 0\n\touter loop\n";
         foreach my $v (@$f) {
            print $fh "\t\tvertex ",join(" ",@$v),"\n";
         }
         print $fh "\tendloop\nendfacet\n";
      }
      print $fh "endsolid\n";
      close $fh;
   }
}

sub stlTransform {
   my($p,$t) = @_;
   my $n = 0;
   my $nn = 0;
   my $pn = { };

   my(@min,@max);
   $min[0] = $min[1] = $min[2] = 1e6;
   $max[0] = $max[1] = $max[2] = -1e6;
   
   foreach my $f (@{$p->{facets}}) {
      my @nf;
      foreach my $v (@$f) {
         my @nv = &$t(@$v);               # -- per vertice
         push(@nf,\@nv) if(@nv==3);
      }
      if(@nf==3) {
         $pn->{facets}->[$n++] = \@nf;
         $nn++;
      } else {
         $pn->{facets}->[$n++] = $f;
         @nf = @$f;
      }
      for(my $i=0; $i<3; $i++) {          # -- 3 vertices per face
         for(my $j=0; $j<3; $j++) {       # -- x,y,z
            # -- update min/max
            $min[$j] = $nf[$i]->[$j] if($nf[$i]->[$j]<$min[$j]);
            $max[$j] = $nf[$i]->[$j] if($nf[$i]->[$j]>$max[$j]);
         }
      }
   }
   # -- keep min/max/size up-to-date
   $pn->{min} = \@min;
   $pn->{max} = \@max;
   $pn->{size} = [$max[0]-$min[0],$max[1]-$min[1],$max[2]-$min[2]];
   print "$nn of $n facets transformed\n" if($conf{verbose});
   return $pn;
}

sub stlRecenter {
   my($p) = @_;
   print "recenter: " if($conf{verbose});
   print "min @{$p->{min}}, max @{$p->{max}}, " if($conf{verbose});
   my $n = 0;
   return stlTransform($p,sub { 
      my(@p) = @_;
      $p[0] -= ($p->{max}->[0]-$p->{min}->[0])/2;
      $p[1] -= ($p->{max}->[1]-$p->{min}->[1])/2;
      $p[2] -= ($p->{max}->[2]-$p->{min}->[2])/2;
      return(@p);
   });
}

sub stlScale {
   my($p,$s) = @_;

   $s = [@$s[0],@$s[0],@$s[0]] if(ref($s)ne'ARRAY' || @$s!=3);
   print "scale: @$s, " if($conf{verbose});

   my $ns = 1;                   # -- normalized value
   my $adj;
   
   for(my $i=0; $i<3; $i++) {    # -- check any absolute dimension
      $ns = $s->[$i] = $s->[$i]/$p->{size}->[$i], $adj++ if($s->[$i] && $s->[$i]=~/mm$/);
   }
   for(my $i=0; $i<3; $i++) {    # -- adjust any non-set scale factors
      $s->[$i] = $ns, $adj++ if(!$s->[$i]);
   }
   print "adjusted scale: @$s, " if($conf{verbose} && $adj);
   for(my $i=0; $i<3; $i++) {          # -- update size
      $p->{size}->[$i] *= $s->[$i];
   }
   return stlTransform($p,sub { 
      my(@p) = @_;
      return ($p[0]*$s->[0],$p[1]*$s->[1],$p[2]*$s->[2]);
   });
}

sub stlRotate {
   my($p,$s) = @_;
   my(@r) = ($s->[0] * pi/180,$s->[1] * pi/180,$s->[2] * pi/180);
   print "rotate: @$s, " if($conf{verbose});
   return stlTransform($p,sub { 
      my(@p) = @_;
      my(@pn);
      # -- https://ch.mathworks.com/matlabcentral/answers/123763-how-to-rotate-entire-3d-data-with-x-y-z-values-along-a-particular-axis-say-x-axis
      # -- x
      $pn[0] = $p[0];  
      $pn[1] = $p[1]*cos($r[0]) - $p[2]*sin($r[0]);
      $pn[2] = $p[1]*sin($r[0]) + $p[2]*cos($r[0]);
      @p = @pn;
      # -- y
      $pn[0] = $p[0]*cos($r[1]) + $p[2]*sin($r[1]);
      $pn[1] = $p[1];
      $pn[2] = $p[2]*cos($r[1]) - $p[0]*sin($r[1]);
      @p = @pn;
      # -- z
      $pn[0] = $p[0]*cos($r[2]) - $p[1]*sin($r[2]);
      $pn[1] = $p[0]*sin($r[2]) + $p[1]*cos($r[2]);
      $pn[2] = $p[2];
      return (@pn);
   });
}

sub stlTranslate {
   my($p,$s) = @_;
   print "translate: @$s, " if($conf{verbose});
   return stlTransform($p,sub { 
      my(@p) = @_;
      return ($p[0]+$s->[0],$p[1]+$s->[1],$p[2]+$s->[2]);
   });
}

sub stlMirror {
   my($p,$s) = @_;
   print "mirror: @$s, " if($conf{verbose});
   return stlTransform($p,sub { 
      my(@p) = @_;
      return ($p[0]*($s->[0]?-1:1),$p[1]*($s->[1]?-1:1),$p[2]*($s->[2]?-1:1));
   });
}


